- [1. vite nest.js nuxt.js next.js](#1-vite-nestjs-nuxtjs-next.js)
- [2. 前端登录鉴权 动态注册路由](#2-前端登录鉴权-动态注册路由)
- [3. 前端换肤](#3-前端换肤)
- [4. 前端加密](#4-前端加密)
- [5. 从输入URL到页面加载都经历了什么](#5-从输入URL到页面加载都经历了什么)
# 1. vite nest.js nuxt.js next.js
 - vite是一个打包工具，跟webpack一样，但是qiankun微前端框架是用的webpack，vite没办法用，以后再学习  
 - nest.js是基于express的node.js做的框架，连接的mysql数据库，然后用的破解版的navicat去直接查看数据库里的数据，现在会开发增删改查的接口，利用本地检验和jwt，实现了用户的登录和token生成，然后利用scoket.io,学会了建立webscoket连接  
😔**但是接口拦截器半生不熟 , 然后redis还未学习、微服务、grpc也还没学习**
 - nuxt.js是vue框架，为了用来ssr，优化seo的网页搜索，但是现在做的是内网的，只需要spa就行了，不需要去做seo优化
 - next.js是react框架，为了用来ssr
**重点就是源代码是不是可以直接看到，这个还是要学习一下的，如果接下来去的是做外网开发**
# 2. 前端登录鉴权 动态注册路由
**1. 用户登录，获取token，将token存在cookie里**
   - cookie，只有4K，在浏览器关闭的时候会清空
   - localStorage，浏览器关闭也不会清空
   - sessionStorage，页面关闭就会清空，不同页面不互通
   - 所以token要存在cookie里面，这样关闭浏览器，下次就需要重新登录，同一个浏览器，打开多个页面的时候，不需要重复的登录

**2. 根据token，通过新的接口获取userinfo，根据userinfo获取对应权限的路由，通过``` router.addRoutes() ```动态挂载这些路由**
   - userinfo只存在store里，每次刷新页面，就重新根据接口请求
   - userinfo存在localstorage里（没有专门的接口，和token一起返回）
   - 根据userinfo动态添加路由，并把这些路由存在store里面，因为网页一刷新，router和store就一起初始化了，所以要在```router.beforeEach()```路由守卫的时候判断，如果store里没有存对应的路由，就要重新根据根据userinfo动态添加路由

**3. ```router.beforeEach()```路由守卫，先判断是不是白名单，再判断是不是有token，再判断是不是有userinfo**
   - 把userId在sessionStorage和localstorage都存一下，切换页面的时候，先看sessionStorage有没有userId
   - 有，证明是已经打开的页面，判断两个id一不一致，不一致，就退出到登录界面（先登录用户A，再登录用户B）
   - 没有，证明是新开的页面，判断是不是有token
# 3. 前端换肤
本质上是利用scss可以使用变量，实现的换肤
```
$themes: (light: $theme-light,dark: $theme-dark,);
$theme-map: null;
@mixin themes {
  // 本质上，就只是map-get($theme-old, 'background-color1')就可以获取对应的属性
  // 利用[data-theme="#{$theme-name}"]把多个theme抽取出对应的theme，其实也可以利用js来获取对应的theme
  @each $theme-name,
  $map in $themes {
    // & 表示父级元素  !global 表示变量是全局的
    [data-theme="#{$theme-name}"] & {
      /* TODO:先清空赋值，再循环合并，似乎性能上更好？待以后css样式多了再测试吧
      $theme-map: () !global;
      // 循环合并键值对
      @each $key,
      $value in $map {
        $theme-map: map-merge($theme-map,
            ($key: $value,
            )) !global;
      } */
      $theme-map: $map !global;
      @content;
    }
  }
}

@function theme($key) {
  @return map-get($theme-map, $key);
}


//获取背景颜色,需要添加!important的给$cont赋值即可
@mixin background_color($color,$cont:null) {
  @include themes {
      background-color: theme($color) $cont;
  }
}
```
# 4. 前端加密
- MD5加密，不可解密，后端都是直接存的加密后的字符串（撞库解密😳），用的js-md5
- BASE64加密，网上找的代码实现的加密解密
- RSA加密，用的jsencrypt.js
# 5. 从输入URL到页面加载都经历了什么
**1. DNS解析**
 - 一个域名对应一个ip地址，但是一个ip地址可以有多个域名。内网里都是直接ip对应电脑，通过ip访问，外网都是直接通过url（域名）访问的，没有直接访问ip的，所以需要把url传给DNS服务器，DNS服务器返回url对应的ip地址，实现网址到ip地址的转换
 - DNS解析的优化：DNS缓存和DNS负载均衡。DNS负载均衡实际就是DNS重定向，**CDN就是这样,就是一个域名去对应一组ip地址，然后DNS解析的时候，把域名解析到这组ip的其中一个去**
   
**2. TCP连接**  
- **三次握手**，HTTP 协议是使⽤ TCP 作为其传输层协议的  
  
**3. 发送HTTP请求**
- 构建 HTTP 请求报⽂并通过 TCP 协议中发送到服务器指定端⼝  
- 常见方法：GET, POST, PUT, DELETE  
- 请求头：Content-Type ,Authorization , Cookie，Connection(设置为Keep-alive ⽤于告诉客户端本次 HTTP 请求结束之后并不需要关闭 TCP 连接，这样可以使下次 HTTP 请求使⽤相同的 TCP 通道，节省TCP 连接建⽴的时间)。  
- 请求正文：json  
    
**4. 服务器处理请求并返回HTTP报文**
- HTTP 响应报⽂也是由三部分组成: 状态码, 响应报头和响应报⽂（ HTML, CSS, JS, 图⽚等⽂件就放在响应报文里）
- js的执⾏机制就可以看做是⼀个主线程加上⼀个任务队列，同步任务就是放在主线程上执⾏的任务，异步任务是放在任务队列中的任务  
    
**5. 浏览器解析渲染页面**  
- html生成dom树，css生成css树，然后两者合起来，绘制页面（回流和重绘）
- 因为js有可能修改dom结构，所以下载js文件的时候，html文档会挂起渲染过程，等js文件加载完毕、解析完毕，才继续执行渲染，后续所有资源的下载也会被打断，所以js会造成阻塞  
- CSS ⽂件的加载不影响 JS ⽂件的加载，但是却影响JS ⽂件的执⾏。JS 代码执⾏前浏览器必须保证 CSS ⽂件已经下载并加载完毕
     
**6. 连接结束（四次挥手）**



