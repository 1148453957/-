# 1. vue key的作用
dom改变的时候会创建新的vnode，diff算法利用key进行比较，newVnode替换oldVnode
# 2. call apply bind
**本质上就是函数在外面写着，所以把函数作为方法添加到对象里，然后执行函数**
```
function foo() {
  console.log(this.name);
}
obj={
name:1231
}
foo.call(obj,x,y）
转成obj={
name:1231,
foo:function () {
  console.log(this.name);
}
}
 Function.prototype.myCall = function(thisArg, ...args) {...args用了结构赋值，不然不知道到底会传过来多少个参数
    const fn = Symbol('fn')        // 声明一个独有的Symbol属性, 防止fn覆盖已有属性
    thisArg = thisArg || window    // 若没有传入对象或者this, 默认绑定window对象
    thisArg[fn] = this              //  this就是外面的函数，fn,abc什么的都无所谓，就是给obj多加个方法，方法名是fn，方法是外面的函数，然后再执行一下
    const result = thisArg[fn](...args)  // 执行当前函数
    delete thisArg[fn]              // 删除我们声明的fn属性，**用delete删除属性**
    return result                  // 返回函数执行结果
} 
foo.myCall(obj,x,y)
```
** apply和call一样,apply传数组，call是分开传**
```
Function.prototype.myApply = function(thisArg, args) {
    const fn = Symbol('fn')        // 声明一个独有的Symbol属性, 防止fn覆盖已有属性
    thisArg = thisArg || window    // 若没有传入this, 默认绑定window对象
    thisArg[fn] = this              // this指向调用call的对象,即我们要改变this指向的函数
    const result = thisArg[fn](...args)  // 执行当前函数（此处说明一下：虽然apply()接收的是一个数组，但在调用原函数时，依然要展开参数数组。可以对照原生apply()，原函数接收到展开的参数数组）
    delete thisArg[fn]              // 删除我们声明的fn属性
    return result                  // 返回函数执行结果
}
```
# 3. 防抖 节流
多次点击，最后一次才执行
```
function debounce（fn,time）{
let timer=null
 return function(){    
 if(timer) clearTimeout(timer)
timer=setTimeout(()=>{
fn.apply(this,arguments)
},time)
}}
```
第一次立马执行，表单提交，连点确定，只提交一次
```
function debounce（fn,time）{
let timer=null
 return function(){   
 if(timer) clearTimeout(timer)
 if(!timer) fn.apply(this,arguments)
timer=setTimeout(()=>{
timer=null
},time)
}}
```
定期执行一次

function throttle(fn,time){
let run =true
return
}


