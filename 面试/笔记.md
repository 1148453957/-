# 1. vue key的作用
dom改变的时候会创建新的vnode，diff算法利用key进行比较，newVnode替换oldVnode
# 2. call
```
function foo() {
  console.log(this.name);
}
obj={
name:1231
}
foo.call(obj,x,y）
转成obj={
name:1231,
foo:function () {
  console.log(this.name);
}
}
obj.foo(x,y)
Function.prototype.myCall = function (thisArg, ...args) {
  thisArg.fn = this; // this就是外面的函数，fn,abc什么的都无所谓，就是给obj多加个方法，方法名是fn，方法是外面的函数，然后再执行一下
  return thisArg.fn(...args); // 执行函数并return其执行结果
};



 Function.prototype.myCall = function(thisArg, ...args) {
    const fn = Symbol('fn')        // 声明一个独有的Symbol属性, 防止fn覆盖已有属性
    thisArg = thisArg || window    // 若没有传入对象或者this, 默认绑定window对象
    thisArg[fn] = this              // 这个this是函数内的this,this=function foo()      指向调用call的对象,即我们要改变this指向的函数
    const result = thisArg[fn](...args)  // 执行当前函数
    delete thisArg[fn]              // 删除我们声明的fn属性
    return result                  // 返回函数执行结果
} 

foo.myCall(obj,x,y)


```
# 3. 防抖 节流
多次点击，最后一次才执行
```
function debounce（fn,time）{
let timer=null
 return function(){    
 if(timer) clearTimeout(timer)
timer=setTimeout(()=>{
fn.apply(this,arguments)
},time)
}}
```
第一次立马执行，表单提交，连点确定，只提交一次
```
function debounce（fn,time）{
let timer=null
 return function(){   
 if(timer) clearTimeout(timer)
 if(!timer) fn.apply(this,arguments)
timer=setTimeout(()=>{
timer=null
},time)
}}
```
定期执行一次

function throttle(fn,time){
let run =true
return
}


